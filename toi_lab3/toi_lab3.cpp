#include <iostream>
#include <string>
#include <Windows.h>
#include <map>
using namespace std;

// Глобальные переменные для работы с парсером
int sn = 0; // Текущая позиция в строке
string s = ""; // Входная строка для разбора
//9-2)=(q/2)";
bool bad = false; // Флаг ошибки
bool in_comp = false, sign = false, OperatorOr = false; // Флаги для отслеживания состояния парсинга
map<char, double> variables;

#pragma region Additional
// Структура узла дерева
struct TreeNode {
	string inf = ""; // Информация, хранящаяся в узле (оператор, число, переменная и т.д.)
	TreeNode* left = nullptr; // Указатель на левое поддерево
	TreeNode* right = nullptr; // Указатель на правое поддерево
};

// Глобальнйе указатель на корень дерева
TreeNode* Root = nullptr;

// Функция вставки нового узла в дерево
void Insert(TreeNode*& R) {
	R = new TreeNode; // Создаем новый узел
	R->inf = s[sn]; // Записываем текущий символ в узел
}

// Функция очистки дерева
void Delete(TreeNode*& R) {
	if (R != nullptr) { // Проверяем, существует ли узел
		Delete(R->left); // Рекурсивно очищаем левое поддерево
		Delete(R->right); // Рекурсивно очищаем правое поддерево
		delete R; // Удаляем текущий узел
		R = nullptr; // Устанавливаем указатель в nullptr для предотвращения висячих указателей
	}
}

// Функция вывода дерева (постфиксный обход)
void Write(TreeNode*& R) {
	if (R != nullptr) { // Проверяем, существует ли узел
		Write(R->left); // Рекурсивно обходим левое поддерево
		Write(R->right); // Рекурсивно обходим правое поддерево
		cout << R->inf << ' '; // Выводим информацию текущего узла
	}
}

// Функция обработки ошибок
void Error(string errorString) {
	if (!bad) {
		cout << "Обнаружена ошибка в выражении: " << errorString;
		bad = true; // Устанавливаем флаг ошибки
	}
	else return;
	if (sn != -1) cout << "\nСимвол: " << s[sn] << "\nНомер символа: " << sn + 1;
	else cout << "\nСимвол: " << s[s.size() - 1] << "\nНомер символа: " << s.size();
	cout << "\nПрограмма прекращает работу\n"; // Выводим сообщение об ошибке, если ошибка еще не была зафиксирована
}

// Функция перехода к следующему символу
void next() {
	if (sn == -1 || sn >= s.size() - 1) sn = -1; // Проверяем, не вышли ли за границы строки, если да — устанавливаем sn в -1 (конец строки)
	else sn++; // Увеличиваем индекс текущего символа
}

// Проверка, является ли символ цифрой от 1 до 9 (0 обрабатывается отдельно)
bool is_digit1_9(char c) {
	return c >= '1' && c <= '9';
}

// Проверка, является ли символ цифрой (включая 0)
bool is_digit(char c) {
	return c >= '0' && c <= '9';
}

// Проверка, является ли символ буквой (латинской)
bool is_alpha(char c) {
	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
		if (variables.count(c) == 0 && !bad) {// Обеспечиваем уникальность
			string input;
			cout << "Введите значение переменной " << s[sn] << " : ";// Ввод переменной
			cin >> input;
			try {
				variables[c] = stod(input); // Включение в словарь
			}
			catch (...) {
				Error("Ввод не числа");
			}
		}
		if (!bad) return true;
	}
	return false;
}
#pragma endregion

#pragma region Voids
// Прототипы функций обработки выражений
void PartOfComparativeExpression(TreeNode*& R);
void Expression(TreeNode*& R);
void Addend(TreeNode*& R);
void Factor(TreeNode*& R);
void Number(TreeNode*& R);
void SignedElement(TreeNode*& R);
#pragma endregion

#pragma region Numbers
// Функция обработки числа: <Number> ::= <Digit> {<Digit> | '0'}
void Number(TreeNode*& R) {
	Insert(R); // Создаем новый узел и записываем в него текущий символ
	if (sign) R->inf = '-' + R->inf; // Если установлен флаг sign, добавляем знак минус
	next(); // Переходим к следующему символу

	while (sn != -1 && is_digit(s[sn])) { // Пока не конец строки и текущий символ — цифра
		R->inf += s[sn]; // Добавляем цифру к информации узла
		next(); // Переходим к следующему символу
	}
}

// Функция обработки дробной части числа: <Double_Number> ::= (<Digit> | '0') '.' {(<Digit> | '0')}
void PartOfDoubleNumber(TreeNode*& R) {
	R->inf += s[sn]; // Продолжаем запись в узел текущий символ (точку)
	next(); // Переходим к следующему символу
	if (sn == -1 || !is_digit(s[sn])) { // Если конец строки или следующий символ не цифра
		Error("Ожидалась цифра после ',' в дробном числе"); // Выдаем ошибку
		return;
	}

	while (sn != -1 && is_digit(s[sn])) { // Пока не конец строки и текущий символ — цифра
		R->inf += s[sn]; // Добавляем цифру к информации узла
		next(); // Переходим к следующему символу
	}
}

// Функция обработки знакового числа: <SignedElement> ::= '-' (<Number> | <DoubleNumber>)
void SignedElement(TreeNode*& R) {
	sign = true; // Устанавливаем флаг знака
	next(); // Переходим к следующему символу

	if (sn == -1) { // Если конец строки
		Error("Нет числа или переменной после '-'"); // Выдаем ошибку
		return;
	}

	if (is_digit(s[sn])) { // Если текущий символ — цифра
		if (s[sn] == '0') { // Если цифра 0
			R->inf += s[sn]; // Добавляем 0 к информации узла
			next(); // Переходим к следующему символу
			if (sn != -1 && s[sn] == ',') PartOfDoubleNumber(R); // Если есть точка, обрабатываем дробную часть
			else { // Если нет точки
				Error("Ожидалась ',' в знаковом дробном числе"); // Выдаем ошибку
				return;
			}
		}
		else { // Если цифра не 0
			Number(R); // Обрабатываем число
			if (sn != -1 && s[sn] == ',') PartOfDoubleNumber(R); // Если есть точка, обрабатываем дробную часть
		}
	}
	else if (is_alpha(s[sn])) { // Если текущий символ — буква
		Insert(R); // Создаем узел и записываем букву
		R->inf = "-" + R->inf;
		variables[s[sn]] *= -1;
		next(); // Переходим к следующему символу
	}
	else { // Если символ не цифра и не буква
		Error("Неверное знаковый элемент"); // Выдаем ошибку
	}
	sign = false; // Сбрасываем флаг знака
}
#pragma endregion

#pragma region General
// Функция обработки множителя: <Factor> ::= <Letter> | <Number> | '(' <Expression> ')' | <SignedElement>
void Factor(TreeNode*& R) {
	if (sn == -1) { // Если конец строки
		Error("Конец строки в множителе"); // Выдаем ошибку
		return;
	}

	if (s[sn] == '(') { // Если текущий символ — открывающая скобка
		if (sn == 0) in_comp = true; // Устанавливаем флаг сравнения, если это начало строки
		next(); // Переходим к следующему символу
		Expression(R); // Обрабатываем выражение внутри скобок
		if (sn == -1 || s[sn] != ')') { // Если конец строки или нет закрывающей скобки
			Error("Отсутствует закрывающая скобка в множителе"); // Выдаем ошибку
			return;
		}
		next(); // Переходим к следующему символу
	}
	else if (s[sn] == '-') { // Если текущий символ — минус
		SignedElement(R); // Обрабатываем знаковое число
	}
	else if (is_digit(s[sn])) { // Если текущий символ — цифра
		if (s[sn] == '0') { // Если цифра 0
			Insert(R); // Создаем узел и записываем 0
			next(); // Переходим к следующему символу
			if (sn != -1 && s[sn] == ',') PartOfDoubleNumber(R); // Если есть точка, обрабатываем дробную часть
			else if (sn != -1 && is_digit(s[sn])) { // Если следующий символ — цифра (ошибка, так как 0 не может быть началом числа > 0)
				Error("Отсутствует точка после 0 в числе"); // Выдаем ошибку
				return;
			}
		}
		else { // Если цифра не 0
			Number(R); // Обрабатываем число
			if (sn != -1 && s[sn] == ',') PartOfDoubleNumber(R); // Если есть точка, обрабатываем дробную часть
		}
	}
	else if (is_alpha(s[sn])) { // Если текущий символ — буква
		Insert(R); // Создаем узел и записываем букву
		next(); // Переходим к следующему символу
	}
	else { // Если символ не подходит ни под одно правило
		Error("Неверный множитель"); // Выдаем ошибку
	}
}

// Функция обработки слагаемого: <Addend> ::= <Factor> {('*' | '/') <Factor>}
void Addend(TreeNode*& R) {
	Factor(R); // Обрабатываем первый множитель
	if (bad || sn == -1) return;
	while (sn != -1 && (s[sn] == '*' || s[sn] == '/')) { // Пока не конец строки и текущий символ — умножение или деление
		TreeNode* O = new TreeNode; // Создаем новый узел для оператора
		Insert(O); // Записываем оператор в узел
		O->left = R; // Левое поддерево — текущее выражение
		next(); // Переходим к следующему символу
		Factor(O->right); // Обрабатываем следующий множитель в правом поддереве
		R = O; // Обновляем корень дерева
	}
}

// Функция обработки выражения: <Expression> ::= <Addend> {('+' | '-') <Addend>}
void Expression(TreeNode*& R) {
	Addend(R); // Обрабатываем первое слагаемое

	while (sn != -1 && (s[sn] == '+' || s[sn] == '-')) { // Пока не конец строки и текущий символ — плюс или минус
		TreeNode* O = new TreeNode; // Создаем новый узел для оператора
		Insert(O); // Записываем оператор в узел
		O->left = R; // Левое поддерево — текущее выражение
		next(); // Переходим к следующему символу
		Addend(O->right); // Обрабатываем следующее слагаемое в правом поддереве
		R = O; // Обновляем корень дерева
	}
}

#pragma endregion

#pragma region Expressions
// Функция обработки части сравнительного выражения: <PartOfComparativeExpression> ::= ('>' | '<' | '=') '('<Expression>')'
void PartOfComparativeExpression(TreeNode*& R) {
	if (sn == -1 || !(s[sn] == '>' || s[sn] == '<' || s[sn] == '=' || s[sn] == '!')) { // Если конец строки или текущий символ не оператор сравнения
		Error("Неверный оператор сравнения"); // Выдаем ошибку
		return;
	}

	TreeNode* O = new TreeNode; // Создаем новый узел для оператора
	Insert(O); // Записываем оператор в узел
	O->left = R; // Левое поддерево — текущее выражение
	next(); // Переходим к следующему символу

	if (sn == -1 || s[sn] != '(') { // Если конец строки или нет открывающей скобки
		Error("Ожидалась '(' после оператора сравнения"); // Выдаем ошибку
		return;
	}
	next(); // Переходим к следующему символу
	Expression(O->right); // Обрабатываем выражение в правом поддереве
	if (sn == -1 || s[sn] != ')') { // Если конец строки или нет закрывающей скобки
		Error("Отсутствует закрывающая скобка после первого выражения"); // Выдаем ошибку
		return;
	}
	R = O; // Обновляем корень дерева
	next(); // Переходим к следующему символу
}

// Функция обработки отрицания: 'не' '(' <Expression> <PartOfComparativeExpression> ')'
void BooleanExpressionNot(TreeNode*& R) {
	if (s[sn] == 'н') { // Если текущий символ — 'н' (начало "не")
		next(); // Переходим к следующему символу
		if (sn != -1 && s[sn] == 'е') { // Если следующий символ — 'е'
			next(); // Переходим к следующему символу
			if (sn != -1 && s[sn] == '(') { // Если следующий символ — открывающая скобка
				next(); // Переходим к следующему символу

				TreeNode* O = new TreeNode; // Создаем новый узел для оператора
				O->inf = "не"; // Записываем оператор в узел
				Expression(O->right); // Обрабатываем выражение
				PartOfComparativeExpression(O->right); // Обрабатываем сравнение
				R = O;
				if (sn != -1 && s[sn] == ')') next(); // Если есть закрывающая скобка, переходим к следующему символу
				else { // Если нет закрывающей скобки
					Error("Отсутствует закрывающая скобка после 'не'"); // Выдаем ошибку
				}
			}
			else { // Если нет открывающей скобки
				Error("Ожидалась '(' после 'не'"); // Выдаем ошибку
			}
		}
		else { // Если нет 'е'
			Error("Ожидалась 'е' после 'н' для 'не'"); // Выдаем ошибку
		}
	}
}

// Функция обработки сравнения: '(' <Expression> ')' <PartOfComparativeExpression>
void BooleanExpression(TreeNode*& R) { //(...)=(...), (...)=(...)
	if (sn != -1 && s[sn] == '(') { // Если текущий символ — открывающая скобка
		next(); // Переходим к следующему символу
		Expression(R); // Обрабатываем выражение
		if (sn != -1 && s[sn] == ')') { // Если есть закрывающая скобка
			next(); // Переходим к следующему символу
			PartOfComparativeExpression(R); // Обрабатываем сравнение =(...)
			if (sn != -1 && s[sn] == ',') { // Если есть запятая (для "и")
				TreeNode* O = new TreeNode; // Создаем новый узел для оператора
				if (OperatorOr) O->inf = "или";
				else O->inf = "и";
				O->left = R; // Левое поддерево — текущее выражение
				R = O; // Обновляем корень дерева
				next(); // Переходим к следующему символу
				if (sn != -1 && s[sn] == '(') { // Если есть открывающая скобка
					next(); // Переходим к следующему символу
					Expression(O->right); // Обрабатываем выражение в правом поддереве
					if (sn != -1 && s[sn] == ')') { // Если есть закрывающая скобка
						next(); // Переходим к следующему символу
						PartOfComparativeExpression(O->right); // Обрабатываем сравнение в правом поддереве
					}
					else { // Если нет закрывающей скобки
						Error("Ожидалась ')' в выражении 'и'"); // Выдаем ошибку
					}
				}
				else { // Если нет открывающей скобки
					Error("Ожидалась ',' в выражении 'и'"); // Выдаем ошибку
				}
			}
			else { // Если нет запятой
				Error("Отсутствует закрывающая скобка после первого выражения в 'и'"); // Выдаем ошибку
			}
		}
		else { // Если нет закрывающей скобки
			Error("Отсутствует открывающая скобка первого выражения в 'и'"); // Выдаем ошибку
		}
	}
}

// Функция обработки логических операторов "и" и "или"
void BooleanExpressionAndOr(TreeNode*& R) {
	// Проверка "и" & "или"
	if (sn != -1 && s[sn] == 'и') { // Если текущий символ — 'и'
		next(); // Переходим к следующему символу
		if (sn != -1 && s[sn] == '(') { // Если следующий символ — открывающая скобка
			next(); // Переходим к следующему символу
			BooleanExpression(R); // Обрабатываем выражение
			if (sn != -1 && s[sn] == ')') next(); // Если есть закрывающая скобка, переходим к следующему символу
			else { // Если нет закрывающей скобки
				Error("Отсутствует закрывающая скобка после второго выражения в 'и'"); // Выдаем ошибку
			}
		}
		else if (sn != -1 && s[sn] == 'л') { // Если следующий символ — 'л' (начало "или")
			next(); // Переходим к следующему символу
			if (sn != -1 && s[sn] == 'и') { // Если следующий символ — 'и'
				next(); // Переходим к следующему символу
				OperatorOr = true;
				if (sn != -1 && s[sn] == '(') { // Если следующий символ — открывающая скобка
					next(); // Переходим к следующему символу
					BooleanExpression(R); // Обрабатываем выражение
					if (sn != -1 && s[sn] == ')') next(); // Если есть закрывающая скобка, переходим к следующему символу
					else { // Если нет закрывающей скобки
						Error("Отсутствует закрывающая скобка после второго выражения в 'и'"); // Выдаем ошибку
					}
				}
				else { // Если нет открывающей скобки
					Error("Ожидалась '(' после 'или'"); // Выдаем ошибку
					bad = true;
				}
			}
			else { // Если нет 'и'
				Error("Ожидалась 'и' после 'л' для 'или'"); // Выдаем ошибку
				bad = true;
			}
		}
		else { // Если нет 'л'
			Error("Ожидалась 'л' после 'и' для 'или'"); // Выдаем ошибку
			bad = true;
		}
	}
}
#pragma endregion

// Вычисление выражения по дереву
double Evaluate(TreeNode* R) {
	if (R == nullptr) return 0.0;

	// Листовой узел (число или переменная)
	if (R->left == nullptr && R->right == nullptr) {
		if (R->inf[0] == '-') {
			if (is_alpha(R->inf[1])) return variables[R->inf[1]];// Знаковая переменная
		}
		if (is_alpha(R->inf[0])) return variables[R->inf[0]];// Переменная
		else { // Число
			return stod(R->inf); // Используем stod для преобразования строки в double
		}
	}
	else { // Осуществляем логику логического оператора НЕ
		if (R->inf == "не") {
			double rightVal = Evaluate(R->right);
			return (rightVal != 0.0) ? 0.0 : 1.0;
		}

		double leftVal = Evaluate(R->left);// Достаем слагаемые/множители
		double rightVal = Evaluate(R->right);

		if (R->inf == "+") return leftVal + rightVal;// Осуществляем логику арифметических операторов
		if (R->inf == "-") return leftVal - rightVal;
		if (R->inf == "*") return leftVal * rightVal;
		if (R->inf == "/") {
			if (rightVal == 0.0) {
				Error("\nОшибка: деление на ноль\n");
			}
			return leftVal / rightVal;
		}

		if (R->inf == ">") return (leftVal > rightVal) ? 1.0 : 0.0;// Осуществляем логику операторов сравнения
		if (R->inf == "<") return (leftVal < rightVal) ? 1.0 : 0.0;
		if (R->inf == "=") return (leftVal == rightVal) ? 1.0 : 0.0;
		if (R->inf == "!") return (leftVal != rightVal) ? 1.0 : 0.0;

		if (R->inf == "и") return (leftVal != 0.0 && rightVal != 0.0) ? 1.0 : 0.0; // Осуществляем логику оставшихся логических операторов
		if (R->inf == "или") return (leftVal != 0.0 || rightVal != 0.0) ? 1.0 : 0.0;

		return 0.0;
	}
}

//Конец, вывод и работа с пользователем
void end() {
	cout << "Строка синтаксически правильна\n"; // Если ошибок нет, выводим сообщение об успешном разборе
	cout << "Построено дерево для выражения (вывод в форме ОПЗ): ";
	Write(Root); // Если дерево не пустое, выводим его содержимое
	cout << "\nРезультат вычисления: " << Evaluate(Root);
}

// Главная функция программы
int main() {
	setlocale(LC_ALL, "Russian"); // Устанавливаем локаль для вывода кириллицы
	SetConsoleOutputCP(1251); // Устанавливаем кодировку консоли для вывода
	SetConsoleCP(1251); // Устанавливаем кодировку консоли для ввода

	cout << "Памятка по правилам:\n1. Вводите выражения без пробелов\n2. Используйте скобки для приоритетов операций\n3. Можете использовать отрицательные числа и переменные\n4. Не ставьте знак минуса перед выражениями, умножьте на (-1)\n5. Используйте знаки '>, <, =, !' и конструкцию (...)?(...) для сравнений\n6. Используйте оперторы 'не, и, или' для логических выражений\n7. Используйте конструкцию 'не/и/или'((...)?(...),(...)?(...)) для логических выражений\n8. Множественные операции доступны только для арифметики\n9. Не смешивайте виды выражений\n10. Дробные числа записывайте с запятой\nВведите выражение (без пробелов): "; // Выводим правила и просим входную строку
	string input;
	cin >> input;
	s += input;

	BooleanExpressionNot(Root); // Обрабатываем отрицание
	BooleanExpressionAndOr(Root); // Обрабатываем логические операторы "и" и "или"

	// Первичный вызов
	if (sn != -1) Expression(Root); // Если не конец строки, обрабатываем выражение
	// Если найдено сравнение, то переквалифицируем в сравнительное выражение
	if (in_comp && sn != -1) PartOfComparativeExpression(Root); // Обрабатываем сравнение

	// Проверка на оставшиеся символы
	if (sn != -1) { // Если остались необработанные символы
		Error("Остались лишние символы в конце выражения"); // Выдаем ошибку
		bad = true;
	}

	if (!bad) {
		end();
		string repeat;
		if (variables.size() > 0) {
			cout << "\nХотите ввести переменные повторно? (д/н): ";
			cin >> repeat;
			while (repeat == "д") {
				for (map<char, double>::iterator it = variables.begin(); it != variables.end(); ++it) {
					string input;
					cout << "Введите значение переменной " << it->first << " : "; // Используем ключ из variables
					cin >> input;
					// Заменяем запятую на точку для stod
					for (char& ch : input) {
						if (ch == ',') ch = '.';
					}
					variables[it->first] = stod(input); // Обновляем значение в словаре
				}
				end(); // Пересчитываем выражение с новыми значениями
				cout << "\nХотите ввести переменные повторно? (д/н): ";
				cin >> repeat;
			}
		}
	}
	Delete(Root);
	return 0; // Завершаем программу
}