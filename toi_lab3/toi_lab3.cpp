#include <iostream>
#include <string>
#include <Windows.h>
#include <map>
using namespace std; //!!! Скобки у отриц не обязательны для удобства и универсальности. Отрицательные выр-ия не пред-ны, домножайте на -1

// Глобальные переменные для работы с парсером
int sn = 0; // Текущая позиция в строке
string s = "и((9)!(1),(2)>(3))"; // Входная строка для разбора
//9-2)=(q/2)";
bool bad = false; // Флаг ошибки
bool in_comp = false, sign = false, OperatorOr = false; // Флаги для отслеживания состояния парсинга
map<char, int> perms;

#pragma region Additional
// Структура узла дерева
struct TreeNode {
    string inf = ""; // Информация, хранящаяся в узле (оператор, число, переменная и т.д.)
    TreeNode* left = nullptr; // Указатель на левое поддерево
    TreeNode* right = nullptr; // Указатель на правое поддерево
};

// Глобальные указатели на корни деревьев
TreeNode* Root = nullptr; // Корень основного дерева

// Функция вставки нового узла в дерево
void Insert(TreeNode*& R) {
    R = new TreeNode; // Создаем новый узел
    R->inf = s[sn]; // Записываем текущий символ в узел
}

// Функция очистки дерева
void Delete(TreeNode*& R) {
    if (R != nullptr) { // Проверяем, существует ли узел
        Delete(R->left); // Рекурсивно очищаем левое поддерево
        Delete(R->right); // Рекурсивно очищаем правое поддерево
        delete R; // Удаляем текущий узел
        R = nullptr; // Устанавливаем указатель в nullptr для предотвращения висячих указателей
    }
}

// Функция вывода дерева (постфиксный обход)
void Write(TreeNode*& R) {
    if (R != nullptr) { // Проверяем, существует ли узел
        Write(R->left); // Рекурсивно обходим левое поддерево
        Write(R->right); // Рекурсивно обходим правое поддерево
        cout << R->inf << ' '; // Выводим информацию текущего узла
    }
}

// Функция обработки ошибок
void Error(string s) {
    if (!bad) cout << "Обнаружена ошибка в выражении: " << s << "\nПрограмма прекращает работу\n"; // Выводим сообщение об ошибке, если ошибка еще не была зафиксирована
    Delete(Root); // Очищаем дерево
    bad = true; // Устанавливаем флаг ошибки
} //!!!добавить ошибку с пробелами

// Функция перехода к следующему символу
void next() {
    if (sn == -1 || sn >= s.size() - 1) sn = -1; // Проверяем, не вышли ли за границы строки, если да — устанавливаем sn в -1 (конец строки)
    else {
        sn++; // Увеличиваем индекс текущего символа
    }
}

// Проверка, является ли символ цифрой от 1 до 9 (0 обрабатывается отдельно)
bool is_digit1_9(char c) {
    return c >= '1' && c <= '9';
}

// Проверка, является ли символ цифрой (включая 0)
bool is_digit(char c) {
    return c >= '0' && c <= '9';
}

// Проверка, является ли символ буквой (латинской)
bool is_alpha(char c) {
    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
        if (perms.count(s[sn]) == 0) {
            int input;
            cout << "Введите значение переменной " << s[sn] << " : ";
            cin >> input;
            perms[s[sn]] = input;
        }
        return true;
    }
    return false;
}
#pragma endregion

#pragma region Voids
// Прототипы функций обработки выражений
void PartOfComparativeExpression(TreeNode*& R);
void Expression(TreeNode*& R);
void Addend(TreeNode*& R);
void Factor(TreeNode*& R);
void Number(TreeNode*& R);
void SignedNumber(TreeNode*& R);
#pragma endregion

#pragma region Numbers
// Функция обработки числа: <Number> ::= <Digit> {<Digit> | '0'}
void Number(TreeNode*& R) {
    Insert(R); // Создаем новый узел и записываем в него текущий символ
    if (sign) R->inf = '-' + R->inf; // Если установлен флаг sign, добавляем знак минус
    next(); // Переходим к следующему символу

    while (sn != -1 && is_digit(s[sn])) { // Пока не конец строки и текущий символ — цифра
        R->inf += s[sn]; // Добавляем цифру к информации узла
        next(); // Переходим к следующему символу
    }
}

// Функция обработки дробной части числа: <Double_Number> ::= (<Digit> | '0') '.' {(<Digit> | '0')}
void PartOfDoubleNumber(TreeNode*& R) {
    R->inf+=s[sn]; // Продолжаем запись в узел текущий символ (точку)
    next(); // Переходим к следующему символу
    if (sn == -1 || !is_digit(s[sn])) { // Если конец строки или следующий символ не цифра
        Error("Ожидалась цифра после ',' в дробном числе"); // Выдаем ошибку
        return;
    }

    while (sn != -1 && is_digit(s[sn])) { // Пока не конец строки и текущий символ — цифра
        R->inf += s[sn]; // Добавляем цифру к информации узла
        next(); // Переходим к следующему символу
    }
}

// Функция обработки знакового числа: <Sign_Number> ::= '-' (<Number> | <Double_Number>)
void SignedNumber(TreeNode*& R) {
    sign = true; // Устанавливаем флаг знака
    next(); // Переходим к следующему символу

    if (sn == -1) { // Если конец строки
        Error("Нет числа или переменной после '-'"); // Выдаем ошибку
        return;
    }

    if (is_digit(s[sn])) { // Если текущий символ — цифра
        if (s[sn] == '0') { // Если цифра 0
            R->inf += s[sn]; // Добавляем 0 к информации узла
            next(); // Переходим к следующему символу
            if (sn != -1 && s[sn] == ',') PartOfDoubleNumber(R); // Если есть точка, обрабатываем дробную часть
            else { // Если нет точки
                Error("Ожидалась ',' в знаковом дробном числе"); // Выдаем ошибку
                return;
            }
        }
        else { // Если цифра не 0
            Number(R); // Обрабатываем число
            if (sn != -1 && s[sn] == ',') PartOfDoubleNumber(R); // Если есть точка, обрабатываем дробную часть
        }
    }
    else if (is_alpha(s[sn])) { // Если текущий символ — буква
        Insert(R); // Создаем узел и записываем букву
        next(); // Переходим к следующему символу
    }
    else { // Если символ не цифра и не буква
        Error("Неверное знаковое число"); // Выдаем ошибку
    }
    sign = false; // Сбрасываем флаг знака
}
#pragma endregion

// Функция обработки множителя: <Factor> ::= <Letter> | <Number> | '(' <Expression> ')' | <Sign_Number>
void Factor(TreeNode*& R) {
    if (sn == -1) { // Если конец строки
        Error("Конец строки в множителе"); // Выдаем ошибку
        return;
    }

    if (s[sn] == '(') { // Если текущий символ — открывающая скобка
        if (sn == 0) in_comp = true; // Устанавливаем флаг сравнения, если это начало строки
        next(); // Переходим к следующему символу
        Expression(R); // Обрабатываем выражение внутри скобок
        if (sn == -1 || s[sn] != ')') { // Если конец строки или нет закрывающей скобки
            Error("Отсутствует закрывающая скобка в множителе"); // Выдаем ошибку
            return;
        }
        next(); // Переходим к следующему символу
    }
    else if (s[sn] == '-') { // Если текущий символ — минус
        SignedNumber(R); // Обрабатываем знаковое число
    }
    else if (is_digit(s[sn])) { // Если текущий символ — цифра
        if (s[sn] == '0') { // Если цифра 0
            Insert(R); // Создаем узел и записываем 0
            next(); // Переходим к следующему символу
            if (sn != -1 && s[sn] == ',') PartOfDoubleNumber(R); // Если есть точка, обрабатываем дробную часть
            else if (is_digit(s[sn])) { // Если следующий символ — цифра (ошибка, так как 0 не может быть началом числа > 0)
                Error("Отсутствует точка после 0 в числе"); // Выдаем ошибку
                return;
            }
        }
        else { // Если цифра не 0
            Number(R); // Обрабатываем число
            if (sn != -1 && s[sn] == ',') PartOfDoubleNumber(R); // Если есть точка, обрабатываем дробную часть
        }
    }
    else if (is_alpha(s[sn])) { // Если текущий символ — буква
        Insert(R); // Создаем узел и записываем букву
        next(); // Переходим к следующему символу
    }
    else { // Если символ не подходит ни под одно правило
        Error("Неверный множитель"); // Выдаем ошибку
    }
}

// Функция обработки слагаемого: <Addend> ::= <Factor> {('*' | '/') <Factor>}
void Addend(TreeNode*& R) {
    Factor(R); // Обрабатываем первый множитель
    if (bad || sn == -1) return; // Если ошибка или конец строки, выходим
    while (sn != -1 && (s[sn] == '*' || s[sn] == '/')) { // Пока не конец строки и текущий символ — умножение или деление
        TreeNode* O = new TreeNode; // Создаем новый узел для оператора
        Insert(O); // Записываем оператор в узел
        O->left = R; // Левое поддерево — текущее выражение
        next(); // Переходим к следующему символу
        Factor(O->right); // Обрабатываем следующий множитель в правом поддереве
        R = O; // Обновляем корень дерева
    }
}

// Функция обработки выражения: <Expression> ::= <Addend> {('+' | '-') <Addend>}
void Expression(TreeNode*& R) {
    Addend(R); // Обрабатываем первое слагаемое
    TreeNode* O; // Временная переменная для нового узла

    while (sn != -1 && (s[sn] == '+' || s[sn] == '-')) { // Пока не конец строки и текущий символ — плюс или минус
        TreeNode* O = new TreeNode; // Создаем новый узел для оператора
        Insert(O); // Записываем оператор в узел
        O->left = R; // Левое поддерево — текущее выражение
        next(); // Переходим к следующему символу
        Addend(O->right); // Обрабатываем следующее слагаемое в правом поддереве
        R = O; // Обновляем корень дерева
    }
}

#pragma region Expressions
// Функция обработки части сравнительного выражения: <PartOfComparativeExpression> ::= ('>' | '<' | '=') '('Expression')'
void PartOfComparativeExpression(TreeNode*& R) {
    if (sn == -1 || !(s[sn] == '>' || s[sn] == '<' || s[sn] == '=' || s[sn] == '!')) { // Если конец строки или текущий символ не оператор сравнения
        Error("Неверный оператор сравнения"); // Выдаем ошибку
        return;
    }
    
    TreeNode* O = new TreeNode; // Создаем новый узел для оператора
    Insert(O); // Записываем оператор в узел
    O->left = R; // Левое поддерево — текущее выражение
    next(); // Переходим к следующему символу

    if (sn == -1 || s[sn] != '(') { // Если конец строки или нет открывающей скобки
        Error("Ожидалась '(' после оператора сравнения"); // Выдаем ошибку
        return;
    }
    next(); // Переходим к следующему символу
    Expression(O->right); // Обрабатываем выражение в правом поддереве
    if (sn == -1 || s[sn] != ')') { // Если конец строки или нет закрывающей скобки
        Error("Отсутствует закрывающая скобка после первого выражения"); // Выдаем ошибку
        return;
    }
    R = O; // Обновляем корень дерева
    next(); // Переходим к следующему символу
}

// Функция обработки отрицания: 'не' '(' <Expression> <PartOfComparativeExpression> ')'
void BooleanExpressionNot(TreeNode*& R) {
    if (s[sn] == 'н') { // Если текущий символ — 'н' (начало "не")
        next(); // Переходим к следующему символу
        if (sn != -1 && s[sn] == 'е') { // Если следующий символ — 'е'
            next(); // Переходим к следующему символу
            if (sn != -1 && s[sn] == '(') { // Если следующий символ — открывающая скобка
                next(); // Переходим к следующему символу

                TreeNode* O = new TreeNode; // Создаем новый узел для оператора
                O->inf="не"; // Записываем оператор в узел
                Expression(O->right); // Обрабатываем выражение
                PartOfComparativeExpression(O->right); // Обрабатываем сравнение
                R = O;
                if (sn != -1 && s[sn] == ')') next(); // Если есть закрывающая скобка, переходим к следующему символу
                else { // Если нет закрывающей скобки
                    Error("Отсутствует закрывающая скобка после 'не'"); // Выдаем ошибку
                }
            }
            else { // Если нет открывающей скобки
                Error("Ожидалась '(' после 'не'"); // Выдаем ошибку
            }
        }
        else { // Если нет 'е'
            Error("Ожидалась 'е' после 'н' для 'не'"); // Выдаем ошибку
        }
    }
}

// Функция обработки сравнения: '(' <Expression> ')' <PartOfComparativeExpression>
void BooleanExpression(TreeNode*& R) { //(...)=(...), (...)=(...)
    if (sn != -1 && s[sn] == '(') { // Если текущий символ — открывающая скобка
        next(); // Переходим к следующему символу
        Expression(R); // Обрабатываем выражение
        if (sn != -1 && s[sn] == ')') { // Если есть закрывающая скобка
            next(); // Переходим к следующему символу
            PartOfComparativeExpression(R); // Обрабатываем сравнение =(...)
            if (sn != -1 && s[sn] == ',') { // Если есть запятая (для "и")
                TreeNode* O = new TreeNode; // Создаем новый узел для оператора
                if (OperatorOr) O->inf = "или";
                else O->inf = "и";
                O->left = R; // Левое поддерево — текущее выражение
                R = O; // Обновляем корень дерева
                next(); // Переходим к следующему символу
                if (sn != -1 && s[sn] == '(') { // Если есть открывающая скобка
                    next(); // Переходим к следующему символу
                    Expression(O->right); // Обрабатываем выражение в правом поддереве
                    if (sn != -1 && s[sn] == ')') { // Если есть закрывающая скобка
                        next(); // Переходим к следующему символу
                        PartOfComparativeExpression(O->right); // Обрабатываем сравнение в правом поддереве
                    }
                    else { // Если нет закрывающей скобки
                        Error("Ожидалась ')' в выражении 'и'"); // Выдаем ошибку
                    }
                }
                else { // Если нет открывающей скобки
                    Error("Ожидалась ',' в выражении 'и'"); // Выдаем ошибку
                }
            }
            else { // Если нет запятой
                Error("Отсутствует закрывающая скобка после первого выражения в 'и'"); // Выдаем ошибку
            }
        }
        else { // Если нет закрывающей скобки
            Error("Отсутствует открывающая скобка первого выражения в 'и'"); // Выдаем ошибку
        }
    }
}

// Функция обработки логических операторов "и" и "или"
void BooleanExpressionAndOr(TreeNode*& R) {
    // Проверка "и" & "или"
    if (sn != -1 && s[sn] == 'и') { // Если текущий символ — 'и'
        next(); // Переходим к следующему символу
        if (sn != -1 && s[sn] == '(') { // Если следующий символ — открывающая скобка
            next(); // Переходим к следующему символу
            BooleanExpression(R); // Обрабатываем выражение
            if (sn != -1 && s[sn] == ')') next(); // Если есть закрывающая скобка, переходим к следующему символу
            else { // Если нет закрывающей скобки
                Error("Отсутствует закрывающая скобка после второго выражения в 'и'"); // Выдаем ошибку
            }
        }
        else if (sn != -1 && s[sn] == 'л') { // Если следующий символ — 'л' (начало "или")
            next(); // Переходим к следующему символу
            if (sn != -1 && s[sn] == 'и') { // Если следующий символ — 'и'
                next(); // Переходим к следующему символу
                OperatorOr = true;
                if (sn != -1 && s[sn] == '(') { // Если следующий символ — открывающая скобка
                    next(); // Переходим к следующему символу
                    BooleanExpression(R); // Обрабатываем выражение
                    if (sn != -1 && s[sn] == ')') next(); // Если есть закрывающая скобка, переходим к следующему символу
                    else { // Если нет закрывающей скобки
                        Error("Отсутствует закрывающая скобка после второго выражения в 'и'"); // Выдаем ошибку
                    }
                }
                else { // Если нет открывающей скобки
                    Error("Ожидалась '(' после 'или'"); // Выдаем ошибку
                    bad = true;
                }
            }
            else { // Если нет 'и'
                Error("Ожидалась 'и' после 'л' для 'или'"); // Выдаем ошибку
                bad = true;
            }
        }
        else { // Если нет 'л'
            Error("Ожидалась 'л' после 'и' для 'или'"); // Выдаем ошибку
            bad = true;
        }
    }
}
#pragma endregion

double Evaluate(TreeNode* R) {
    if (R == nullptr) return 0.0;

    // Листовой узел (число или переменная)
    if (R->left == nullptr && R->right == nullptr) {
        if (is_alpha(R->inf[0])) { // Переменная
            return perms[R->inf[0]];
        }
        else { // Число
            return stod(R->inf); // Используем stod для преобразования строки в double
        }
    }
    else { // Узел с оператором
        if (R->inf == "не") {
            double rightVal = Evaluate(R->right);
            return (rightVal != 0.0) ? 0.0 : 1.0;
        }

        double leftVal = Evaluate(R->left);
        double rightVal = Evaluate(R->right);

        if (R->inf == "+") return leftVal + rightVal;
        if (R->inf == "-") return leftVal - rightVal;
        if (R->inf == "*") return leftVal * rightVal;
        if (R->inf == "/") {
            if (rightVal == 0.0) {
                Error("Ошибка: деление на ноль\n");
            }
            return leftVal / rightVal;
        }

        if (R->inf == ">") return (leftVal > rightVal) ? 1.0 : 0.0;
        if (R->inf == "<") return (leftVal < rightVal) ? 1.0 : 0.0;
        if (R->inf == "=") return (leftVal == rightVal) ? 1.0 : 0.0;
        if (R->inf == "!") return (leftVal != rightVal) ? 1.0 : 0.0;

        if (R->inf == "и") return (leftVal != 0.0 && rightVal != 0.0) ? 1.0 : 0.0;
        if (R->inf == "или") return (leftVal != 0.0 || rightVal != 0.0) ? 1.0 : 0.0;

        return 0.0;
    }
}

// Главная функция программы
int main() {
    setlocale(LC_ALL, "Russian"); // Устанавливаем локаль для вывода кириллицы
    SetConsoleOutputCP(1251); // Устанавливаем кодировку консоли для вывода
    SetConsoleCP(1251); // Устанавливаем кодировку консоли для ввода
    cout << s << '\n'; // Выводим входную строку

    BooleanExpressionNot(Root); // Обрабатываем отрицание
    BooleanExpressionAndOr(Root); // Обрабатываем логические операторы "и" и "или"

    // Первичный вызов
    if (sn != -1) Expression(Root); // Если не конец строки, обрабатываем выражение
    // Если найдено сравнение, то переквалифицируем в сравнительное выражение
    if (in_comp && sn != -1) PartOfComparativeExpression(Root); // Обрабатываем сравнение

    // Проверка на оставшиеся символы
    if (sn != -1) { // Если остались необработанные символы
        Error("Остались лишние символы в конце выражения"); // Выдаем ошибку
        bad = true;
    }

    if (!bad) {
        cout << "Строка корректна\n"; // Если ошибок нет, выводим сообщение об успешном разборе
        Write(Root); // Если дерево не пустое, выводим его содержимое
        cout << "\nРезультат вычисления: " << Evaluate(Root);
    }

    Delete(Root);
    return 0; // Завершаем программу
}